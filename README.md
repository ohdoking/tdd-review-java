# TDD Review In Java

## The red-green-refactor process

1. Write a test
2. Run all the tests and confirm that the last one is failing
3. Write the implementation code
4. Run all the tests
5. Refactor(Optional)
6. Repeat

## Test Kind

- Unit tests tests try to verify small units of functionality
- Functional and acceptance tests have a job to verify that the application we're building works as expected, as a whole.
- Integration tests intend to verify that separate units, modules, applications, or even whole systems are properly integrated with each othe

## JaCoCo

Java Code Coverage (JaCoCo) is a well-known tool for measuring test coverage.

### How to use Jacoco

add *build.gradle*
'''
apply plugin: 'jacoco'
// need to over JDK 11(https://github.com/vaskoz/core-java9-impatient/issues/11)
jacoco {
    toolVersion = "0.8.2"
}
'''

![JaCoCo](https://user-images.githubusercontent.com/4298268/52576042-a6dee480-2e1f-11e9-98ea-2bfa5b94f47a.png)
 
## TIP

### Use descriptive names for test methods

One of the benefits is that it helps to understand the objective of tests.
Using method names that describe tests is beneficial when trying to figure out why some tests failed or when the coverage should be increased with more tests. It should be clear what conditions are set before the test, what actions are performed, and what the expected outcome is.
There are many different ways to name test methods. My preferred method is to name them using the given/when/then syntax used
in BDD scenarios. Given describes (pre)conditions, When describes actions, and Then describes the expected outcome. If a test does not have preconditions (usually set using the @Before and @BeforeClass annotations), Given can be skipped.
Do NOT rely only on comments to provide information about test objectives. Comments do not appear when tests are executed from your favorite IDE, nor do they appear in reports generated by the CI or build tools.

### Write the test before writing the implementation code

The benefits of doing this are as follows: it ensures that testable code is written and ensures that every line of code gets tests written for it.
By writing or modifying the test first, the developer is focused on requirements before starting to work on a code. This is
the main difference when compared to writing tests after the implementation is done. An additional benefit is that with tests first, we are avoiding the danger that the tests work as quality checking instead of quality assurance.

### Rerun all the tests every time the implementation code changes.

This ensures that there is no unexpected side-effect caused by code changes.
Every time any part of the implementation code changes, all tests should be run. Ideally, tests are fast to execute and can be run by a developer locally. Once code is submitted to the version control, all tests should be run again to ensure that there was no problem due to code merges. This is especially important when more than one developer is working on the code. Continuous Integration tools such as Jenkins, Hudson, Travind, Bamboo and Go-CD should be used to pull the code from the repository, compile it, and run tests.

### Write the simplest code to pass the test. This ensures a cleaner and clearer design and avoids unnecessary features

The idea is that the simpler the implementation, the better and easier it is to maintain the product.
The idea adheres to the KISS principle. It states that most systems work best if they are kept simple rather than made complex; therefore, simplicity should be a key goal in design and unnecessary complexity should be avoided.

### Refactor only after all the tests have passed.

Benefits: refactoring is safe

If all the implementation code that can be affected has tests and if they are all passing, it is relatively safe to refactor.
In most cases, there is no need for new tests;
small modifications to existing tests should be enough.
The expected outcome of refactoring is to have all the tests passing both before and after the code is modified.




